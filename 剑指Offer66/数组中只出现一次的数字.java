/*题目描述
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。*/

/*思路:
*我们还是从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果，
* 因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为0，
* 也就是说，在这个结果数字的二进制表示中至少有一位为1。我们在结果数字中找到第一个为1的位的位置，
* 记为第n位。现在我们以第n位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字
* 的第n位都是1，而第二个子数组中每个数字的第n位都是0。由于我们分组的标准是数字中的某一位是1还是0，
* 那么出现了两次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我们不可
* 能把两个相同的数字分配到两个子数组中去，于是我们已经把原数组分成了两个子数组，每个子数组都包含
* 一个只出现一次的数字，而其他数字都出现了两次。我们已经知道如何在数组中找出唯一一个只出现一次的
* 数字，因此，到此为止所有的问题都已经解决了。
举个例子，假设输入数组{2，4，3，6，3，2，5，5}。当我们依次对数组中的每个数字进行异或运算之后，
得到的结果用二进制表示是0010。异或得到的结果中的倒数第二位是1，于是我们根据数字的倒数第二位是
不是1将该数组分为两个子数组。第一个子数组；2，3，6，3，2}中所有数字的倒数第二位都是1，而第二个
子数组4，5，5}中所有数字的倒数第二位都是0。接下来只要分别对这两个子数组求异或，就能找出第一个
子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 */


//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
public class 数组中只出现一次的数字 {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        if(array == null || array.length == 0)
            return;
        int xor = 0;
        for(int i: array)
            xor ^= i;
        int index = findFirstBitsIs1(xor);
        num1[0] = 0;
        num2[0] = 0;
        for(int i:array){
            if(IsBit1(i,index))
                num1[0] ^= i;
            else
                num2[0] ^= i;
        }
    }
//寻找第一个为1的位的index
    int findFirstBitsIs1(int num){
        int index = 0;
        while((num&1)!=1 && index < 32){
            num = num >>1;
            index++;
        }
        return index;
    }

    boolean IsBit1(int num, int index){
        return ((num>>index)&1) == 1;
    }

    /*扩展题目二：数组中唯一只出现一次的数字。
在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。
请找出那个只出现一次的数字。
如果我们把题目稍微改一改，那么就会容易很多：如果数组中的数字除一个只出现一次之外，其他数字都出现了两次。
我们可以用XOR异或位运算解决这个简化的问题。由于两个相同的数字的异或结果是0，我们把数组中所有数字异或的
结果就是那个唯一只出现一次的数字。
可惜这种思路不能解决这里的问题，因为三个相同的数字的异或结果还是该数字。尽管我们这里不能应用异或运算，
我们还是可以沿用位运算的思路。如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现三次。
如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。
我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字
二进制表示中对应的那一位是0；否则就是1。*/

}
