/*
* 给定一个数字，我们按照如下规则把它翻译为字符串：
0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。
一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。
请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。
样例
输入："12258"
输出：5
* */

/*
 *这是一个DP问题：
 * 1.状态怎么表示
 *   f[i]表示前i位数字有多少种不同的翻译方式：
 *       a.如果将第i位翻译成一个单独的字母，则f[i] = f[i-1];
 *       b.如果i-1位和第i位共同翻译成一个字母，则f[i] = f[i-2]+f[i-1]
 *   前i个字母翻译结果的所有情况会被这两部分完全覆盖，且这两部分没有交集。
 *   这两类加起来就是所有的情况。
 *
 * 2.状态如何计算
 * 3.边界
 * */
public class 把数字翻译成字符串 {
    public static int getTranslationCount(String s) {
        char[] sc = s.toCharArray();
        int n = sc.length;
        int[] f = new int[n + 1];
        f[1] = 1;
        for (int i = 2; i <= n; i++) {

            f[i] = f[i - 1];//第i位数字单独翻译成一个字母时，前i个数字的翻译方案数等于前i-1个数字的翻译方案数
//          检查第i-1和第i-2位是否可以组成合法的可翻译为一个字母的数字
//          注意这里下标在f[]中和在sc[]中表示的数位有偏移，在sc中，下标从0开始； 在f[]中，下标从1开始；所以前i位的方案数用f[i]表示，但第i个字符用sc[i-1]表示
            int t = (sc[i - 2] - '0') * 10 + sc[i - 1] - '0';//t表示由第i位和第i-1位数字组成的两位数字
//          第i和第i-1位的组合结果有两种状态不能被翻译成一个字母：一、05这样的前面有0的；二、>=26的。
//          所以只有在10~26之间的数字可以合法的被一个字母翻译
            if (t >= 10 && t <= 25)
//          如果满足上述条件，则前i个数字的翻译方案还可以是前i-2位数字的翻译方案数，
                f[i] += f[i - 2];
        }
        return f[n];
    }

    public static void main(String[] args) {
        getTranslationCount("12258");
    }
}
