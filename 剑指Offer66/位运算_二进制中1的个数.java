/*
题目描述
* 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
* */

/*
* 题解
*迭代进行如下两步，直到 n 变成0为止：

如果 n 在二进制表示下末尾是1，则在答案中加1；
将 n 右移一位，也就是将 nn 在二进制表示下的最后一位删掉；
这里有个难点是如何处理负数。

在C++中如果我们右移一个负整数，系统会自动在最高位补1，这样会导致 n 永远不为0，就死循环了。
解决办法是把 nn 强制转化成无符号整型，这样 n 的二进制表示不会发生改变，但在右移时系统会自动在最高位补0。

在java里面:
<< 表示左移
>> 表示右移 （带符号右移，负数高位补0正数高位补1）
>>> 表示无符号右移（无论正负高位补0）

补充雪菜关于补码的理解：
在十进制下也有补码的概念:
3的补码是7因为 3+7=10；
22的补码是78 因为 22+78 = 100；
就是能把你加到刚好到进位的那个数，就是你的补码；
二进制也是一样:
1的补码是
1111 1111 1111 1111
10的补码是
1111 1111 1111 1110
11的补码是
1111 1111 1111 1101
一个负数在计算机里，用它绝对值的补码表示,
也就是说，-2用2(10)的补码 1111 1111 1111 1110 表示


时间复杂度
每次会将 nn 除以2，最多会除 lognlogn 次，所以时间复杂度是 O(logn)O(logn)。
题解来自大雪菜
* */
public class 位运算_二进制中1的个数 {
    public int NumberOf1(int n)
    {
        int res = 0;
        while(n!=0){
            res += n&1;
            n = n>>>1;
        }
        return res;
    }
}
