/*
* 题目: https://www.acwing.com/problem/content/24/
* 给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。

每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？

例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。

样例
输入：8

输出：18
* */

/*
* 题解来自大雪菜
* 1.至少要剪成两段；
* 2.剪出长度为1的绳子对最大乘积没有贡献，因此如果想乘积最大，则一定不能剪出长度为1的绳子（绳长为2的不得不剪成两根1，绳长为3的不得不剪成1个1一个2）；
* 3.当绳长足够长时(长度大于5)，使得乘积最大的剪法是剪成若干个3和0至两个2：
* 证明如下:
* 假设剪出的某个绳长为n(n>5),则我们可以从中再剪出一个3来,得到的乘积：
* (n-3)*3 > n 的条件是2*n>9, 则说明n>5时将n剪出一个3来的乘积一定比不剪开要大;
* n = 4时 剪成两个 2
* 为什么不剪成多于两个的2呢？
* 因为6 = 2+2+2，乘积为8，剪成3+3，乘积为9
* 所以
* 本题的算法是:
* 如果n除3余1，则 n = 2+2 + 3 + ... +3;
* 如果n除3余2，则  n =2  + 3 + ... +3;
* 如果n除3余0，则  n =3 + ... +3;
* n = 2，3，4的时候需要特判
*
*
* 这道题目是数学中一个很经典的问题。
下面我们给出证明：

首先把一个正整数 NN 拆分成若干正整数只有有限种拆法，所以存在最大乘积。
假设 N=n1+n2+…+nkN=n1+n2+…+nk，并且 n1×n2×…×nkn1×n2×…×nk 是最大乘积。

显然1不会出现在其中；
如果对于某 ii 有 ni≥5ni≥5，那么把 nini 拆分成 3+(ni−3)3+(ni−3)，我们有 3(ni−3)=3ni−9>ni3(ni−3)=3ni−9>ni；
如果 ni=4ni=4，拆成 2+22+2乘积不变，所以不妨假设没有4；
如果有三个以上的2，那么 3×3>2×2×23×3>2×2×2，所以替换成3乘积更大；
综上，选用尽量多的3，直到剩下2或者4时，用2。

时间复杂度分析：当 nn 比较大时，nn 会被拆分成 ⌈n/3⌉⌈n/3⌉ 个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 O(n)O(n)。

作者：yxc
链接：https://www.acwing.com/solution/acwing/content/731/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
* */
public class 发散思维能力_剪绳子 {
    public static int maxProductAfterCutting(int length)
    {
        int res = 1;
        if(length == 2)
            res = 1;
        if(length == 3)
            res = 2;
        if(length == 4)
            res = 4;
        else if(length > 4){
            int n3 = 0;
            if(length%3 == 1){
                n3 = (length-4)/3;
                res *= 4*Math.pow(3,n3);
            }
            if(length%3 == 2){
                n3 = length/3;
                res *= 2*Math.pow(3,n3);
            }
            else if(length%3 == 0){
                n3 = length/3;
                res *=Math.pow(3,n3);
            }
        }
        return res;
    }

    public static void main(String[] args) {
        maxProductAfterCutting(7);
    }

}
