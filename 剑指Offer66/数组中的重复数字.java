/*
*题目一：找出数组中重复的数字。
在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，
也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组（2，3，1，0，
2，5，3}，那么对应的输出是重复的数字2或者3。
* */

public class 数组中的重复数字 {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false

    /*思路:
    用set来测试需要O(n)的空间复杂度
    下面的解法数字的范围利用都在0~n-1的范围内，且数组的长度为n，这样所有数字都可以映射到原数组的下标中
    * 现在让我们重排这个数组。从头到尾依次扫描这个数组中的每个数字。当扫描到下标为i的数字时，首先比较这个数字（用m表示）是不是等于i。
    * 如果是，则接着扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果它和第m个数字相等，就找到了一个重复的数字（该数字在下
    * 标为i和m的位置都出现了）；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、
    * 交换的过程，直到我们发现一个重复的数字。*/

    /*以数组{2，3，1，0，2，5，3}为例来分析找到重复数字的步骤。数组的第0个数字（从0开始计数，和数组的下标保持一致）是2，与它的下标
    不相等，于是把它和下标为2的数字1交换。交换之后的数组是{1，3，2，0，2，，5，3}。此时第0个数字是1，仍然与它的下标不相等，继续把
    它和下标为1的数字3交换，得到数组{3，1，2，0，2，5，3}。接下来继续交换第0个数字3和第3个数字0，得到数组{0，1，2，3，2，5，3}。
    此时第0个数字的数值为0，接着扫描下一个数字。在接下来的几个数字中，下标为1、2、3的3个数字分别为1、2、3，它们的下标和数值都分别
    相等，因此不需要执行任何操作。接下来扫描到下标为4的数字2。由于它的数值与它的下标不相等，再比较它和下标为2的数字。注意到此时数组
    中下标为2的数字也是2，也就是数字2在下标为2和下标为4的两个位置都出现了，因此找到一个重复的数字。*/

    public boolean duplicate(int numbers[],int length,int [] duplication) {
        int p = 0;
        while(p<length){
            if(numbers[p]!=p){
                if(numbers[numbers[p]] != numbers[p]){
                    swap(numbers,p,numbers[p]);
                }
                else{
                    duplication[0] = numbers[p];
                    return true;
                }
            }else {
                p++;
            }
        }
        return false;
    }

    void swap(int[] arr, int x1, int x2){
        int tmp = arr[x1];
        arr[x1] = arr[x2];
        arr[x2] = tmp;
    }

    /*扩展:
    * 题目二：不修改数组找出重复的数字。在一个长度为n+l的数组里的所有数字都在1～n的范围内，
    * 所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。
    * 例如，如果输入长度为8的数组（2，3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。*/

    /*这一题看起来和上面的面试题类似。由于题目要求不能修改输入的数组，我们可以创建一个长度为n+1的辅助数组，
    然后逐一把原数组的每个数字复制到辅助数组。如果原数组中被复制的数字是m，则把它复制到辅助数组中下标为m的位置。
    这样很容易就能发现哪个数字是重复的。由于需要创建一个数组，该方案需要O（n）的辅助空间。

    接下来我们尝试避免使用O（n）的辅助空间。为什么数组中会有重复的数字？假如没有重复的数字，那么在从1～n的范围里
    只有n个数字。由于数组里包含超过n个数字，所以一定包含了重复的数字。看起来在某范围里数字的个数对解决这个问题很重要。
    我们把从1～n的数字从中间的数字m分为两部分，前面一半为1～m，后面一半为m+l～n。如果1～m的数字的数目超过m，那么这
    一半的区间里一定包含重复的数字；否则，另一半m+l～n的区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一
    分为二，直到找到一个重复的数字。这个过程和二分查找算法很类似，只是多了一步统计区间里数字的数目。

    我们以长度为8的数组{2，3，5，4，3，2，6，7}为例分析查找的过程。根据题目要求，这个长度为8的所有数字都在1~7的范围内。中
    间的数字4把1~7的范围分为两段，一段是1~4，另一段是5~7。接下来我们统计1~4这4个数字在数组中出现的次数，它们一共出现了5次，
    因此这4个数字中一定有重复的数字。接下来我们再把1~4的范围一分为二，一段是1、2两个数字，另一段是3、4两个数字。数字1或者2
    在数组中一共出现了两次。我们再统计数字3或者4在数组中出现的次数，它们一共出现了三次。这意味着3、4两个数字中一定有一个重复
    了。我们再分别统计这两个数字在数组中出现的次数。接着我们发现数字3出现了两次，是一个重复的数字。*/

    /*上述代码按照二分查找的思路，如果输入长度为n的数组，那么函数countRange将被调用O（logn）次，每次需要O（n）的时间，
    因此总的时间复杂度是O（nlogn），空间复杂度为O（1）。和最前面提到的需要O（n）的辅助空间的算法相比，这种算法相当于以
    时间换空间。
    需要指出的是，这种算法不能保证找出所有重复的数字。例如，该算法不能找出数组2，3，5，4，3，2，6，7}中重复的数字2。
    这是因为在1~2的范围里有1和2两个数字，这个范围的数字也出现2次，此时我们用该算法不能确定是每个数字各出现一次还是某个数
    字出现了两次。*/
}
