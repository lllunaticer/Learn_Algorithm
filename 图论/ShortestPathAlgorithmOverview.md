# 最短路算法
## 单源最短路
- 所有边权都是正数
  1. 朴素Dijstra算法 。 时间复杂度O(n2), n表示节点个数, 适用于稠密图，即边的数目比较多，边的数目>=节点数目的平方。
  稠密图一般用邻接矩阵来保存。
  2. 堆优化版的Dijstra算法。时间复杂度O(mlogn)，m表示边的数目,n表示节点数目。适用于稀疏图, 边的数目和节点数目一个级别。
  稀疏图一般用邻接表来保存。
  - 为什么Dijkstra算法不能用于由负权边的图？
  dijkstra是基于贪心策略，每次都找一个距源点最近的点，然后将该距离定为这个点到源点的最短路径；但如果存在负权边，那就有可能
  先通过并不是距源点最近的一个次优点，再通过这个负权边，使得路径之和更小，这样就出现了错误。对于下图将A添加到集合中标记已访问，
  之后选出从A到所有节点中的最短的点，于是把C加入集合中标记已访问，之后C不能在更新了，而显然，A与C之间最短路径权值为0（A-B-C）
  ，发生错误。
  
  ![带负权边的图](带负权边的图.jpg)
  
  
- 存在负权边
  1. Bellman-Ford 算法。时间复杂度O(nm), n表示节点数量，m表示边的数量。
  2. SPFA 。一般情况下是O(m),最坏O(nm)。且本算法不适用于要求从A到B中间最少经过k个点的问题。
## 多源汇最短路
Floyd算法，复杂度O(n^3)
```
这些算法都是有向图算法。无向图可以看成特殊的有向图(A和B之间有一条A指向B的边，同时还有一条B指向A的边)。
```
