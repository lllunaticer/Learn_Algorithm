# 背包问题
背包问题的优化就是代码的等价变形或者状态计算公式的等价变形。
## 01背包问题
1. 特点: 每种物品只有一个，所以每种物品最多用一次。

从集合的角度思考这个问题

![](01背包问题动态规划思考图.JPG)

2. 解法:<br>
状态计算公式：
```
f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i])
```
相应的代码:
```
for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
               f[i][j] = f[i-1][j];
               if(j>=v[i]) f[i][j] = Math.max(f[i][j],f[i-1][j-v[i]]+w[i]);
            }
        }
  return f[n][m];
```
3. 优化为1维矩阵

![](二维矩阵.JPG)

如上图所示，如果我们要计算红色部分的f(i,j), 根据状态计算公式f(i,j) = Math.max(f(i-1, j),f(i-1, j-v<sub>i</sub>)+w<sub>i</sub>)。
其中f(i-1, j)就是上一层的蓝色块，而f(i-1, j-v<sub>i</sub>)就是上一层的粉色块。由此可知，计算本层的某一个f(i,j)的时候，只需要用到上一层
的这两个位置的元素。所以可以采用滚动数组的形式来保存上一层的状态，只需要一维的数组。

转为一维数组需要在原来的代码上做等价变形，我们删去矩阵的一个维度，并将内层的循环顺序改为j由大到小的循环。
```
int dfs_1D(){
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {
                g[j] = Math.max(g[j],g[j-v[i]]+w[i]);
            }
        }
    return g[m];
    }
```
至于为什么要将内层的循环顺序改为由大到小:
如下图所示，转为一维矩阵时，我们计算f[j] = Math.max(f[j], f[j-v<sub>i</sub>]+w<sub>i</sub>)。如果我们从左边往右边
更新这个矩阵，由于j-v<sub>i</sub><j, 所以在更新f[j]的时候，f[j-v<sub>i</sub>]已经在这次的外循环中被更新过了。然后而由上面的二维矩阵
分析可知，实际上我们更新f[j]所需要的那个f[j-v<sub>i</sub>]，是上一层循环中的f[j-v<sub>i</sub>]。
如果我们把更新一维矩阵的方向改为从右往左，则在更新f[j]的时候，f[j-v<sub>i</sub>]还没有被更新，这样我们取到的这个f[j-v<sub>i</sub>]就还是
上一层的f[j-v<sub>i</sub>]，这样我们的代码就相当于对二维的代码做了等价变形。

![](一维矩阵.JPG)


## 完全背包问题
1. 特点: 每种物品有无限个, 只要装的下就可以装任意多个。

从集合的角度思考这个问题:

![](完全背包问题动态规划思考图.JPG)

状态转移方程:
```
f[i,j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i], f[i-1][j-2*v[i]]+2*w[i], ... , f[i-1][j-k*v[i]]+k*w[i])
```
```
for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                //状态转移方程f[i,j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i], f[i-1][j-2*v[i]]+2*w[i], ... , f[i-1][j-k*v[i]]+k*w[i])
                //对k循环实现上面的这个方程
                for (int k = 0; k * v[i] <= j; k++)
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
            }
        }
        return f[n][m];
```
2. 优化

可以看出上面解法中为了找出f[i][j]的k个子状态中的最大值，我们友加入了一层循环，导致存在三重循环，算法的复杂度很高。
优化的过程如下:

![](完全背包问题优化.JPG)

经过优化，状态转移方程变为了:
```
f[i,j] = max(f[i-1][j],f[i][j-v[i]]+w[i])
```
这样我们就可以省去一重循环:
```
for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                f[i][j] = f[i - 1][j];
                if (j >= v[i])
                    f[i][j] = Math.max(f[i][j], f[i][j - v[i]] + w[i]);
            }
        }
  return f[n][m];
```
进一步的，我们可以对比一下01背包问题的状态转移方程和完全背包问题的状态转移方程:
01背包:
```
f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i])
```
完全背包问题:
```
f[i][j] = max(f[i-1][j],f[i][j-v[i]]+w[i])
```
可以发现, 01背包问题的第二个状态f[i-1][j-v[i]]是第i-1的f[j-v[i]]，所以在转化为一维数组时，我们要求更新f[j]数组要从右往左更新，这样才能保证使用的f[j-v[i]]是第i-1层的数据。

而完全背包问题的第二个状态f[i][j-v[i]]是第i层的f[j-v[i]]，因此在转为一维数组的过程中，我们更新f[j]时使用的就是本层的已经被更新过的f[j-v[i]], 要达到这个目的，只需对f[j]数组从左往右更新即可。

## 多重背包问题
1. 特点： 每种物品的个数用s<sub>i</sub>给定, 用完就不能再用了。
## 分组背包问题
1. 特点： 所有的物品分为若干组，每组中只能挑选一个物品放入背包。（比如水果组、蔬菜组等）